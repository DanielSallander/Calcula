### Specification: Smart Range Normalization (Auto-Fill Heuristics)

**Introduction**
This feature request addresses **"Context-Aware Relative Reference Resolution,"** specifically handling **Range Inversion** during Auto-Fill operations.

* **Current Behavior:** Dragging a semi-absolute range (e.g., `Start(Relative):End(Absolute)`) past the anchor point typically results in a broken reference where `Start > End`.
* **Desired Behavior:** The engine should detect the crossover of the relative coordinate against the absolute anchor and normalize the range (e.g., flipping the range definition to `Anchor(Absolute):NewEnd(Relative)`).

---

### 1. Architectural Decision

* **Verdict:** **EXTENSION** (Target: `app/extensions/_standard/formula-basic`)
* **Placement Reasoning:**
The Logic of how a string transforms when moved from `(x, y)` to `(x, y+n)` is strictly **content-dependent**.
* **The Core** sees only raw strings. It is agnostic to whether the cell contains a Formula, a Date, or a Fibonacci sequence.
* **The API** must provide the mechanism to intercept the "Drag/Fill" gesture.
* **The Extension** owns the Formula Parser. Only the extension understands that `I10:$I$11` is a range. Therefore, the logic to detect "inversion" (where the start index surpasses the end index) belongs exclusively here. Hardcoding this in the Core violates the **Alien Rule** by forcing the Kernel to understand formula syntax.

---

### 2. Core Implementation (Rust/TS)

* **Generic Capability:** **`FillOperationDelegate`**
The Core currently handles the UI interaction of the "Fill Handle" (the small square at the bottom right of a selection). We need to decouple the *gesture* from the *data mutation*.
Instead of the Core simply copying values or incrementing numbers, it must broadcast a **Service Request** asking: *"Who knows how to generate data for this fill pattern?"*
* **Performance Considerations:**
* **Synchronous vs. Asynchronous:** Fill operations are user-blocking. The resolution must be synchronous or extremely fast (micro-task).
* **Batching:** The Core must accept a `BatchOp` from the provider, not individual cell updates, to prevent triggering the dependency graph (`DepGraph`) re-calculation  times for  cells. It must occur as a single transaction.

---

### 3. API Layer (The Bridge)

* **Contract Definition:** `AutoFillProvider`
We are adding a new Registry to `app/src/api`:
```typescript
// Interface for extensions to register intelligent fill logic
interface AutoFillProvider {
    // Priority allows Formula extension to override Plain Text extension
    priority: number; 

    // The Kernel asks: Can you handle this source data?
    canProvideFill(source: CellRange, context: FillContext): boolean;

    // The Kernel requests: Give me the new data for the target range.
    provideFillData(
        source: CellRange, 
        target: CellRange, 
        direction: Direction
    ): GeneratedCellData[]; 
}

```

* **Hook/Event:**
* **Registry:** `calcula.features.registerAutoFillProvider(provider)`
* **Mechanism:** When the user releases the mouse button on a Drag-Fill, the API iterates through registered providers by priority. The first one to return `true` for `canProvideFill` executes the logic.

---

### 4. Extension Implementation

* **Folder Location:** `app/extensions/_standard/formula-basic`
* **Logic Flow:**
1. ** interception:** The extension registers an `AutoFillProvider` with `priority: 100`.
2. **Detection:** In `canProvideFill`, it parses the source cell. If it starts with `=`, it claims responsibility.
3. **Parsing:** It uses the extension's internal AST parser to identify Reference Nodes (e.g., `I10:$I$11`).
4. **Heuristic (The "Smart" Logic):**
* Calculate the drag delta (e.g., +2 rows).
* Project the new start coordinate: `CurrentStart + Delta`.
* **Check Inversion:** If `NewStart > FixedEnd`:
* Rewrite the AST node.
* Swap the anchor: The "Fixed End" becomes the "Fixed Start".
* The "Moving Start" becomes the "Moving End".
* *Example:* `I10:$I$11` (Start moves down past 11) -> becomes `I$11:I13`.

5. **Generation:** Serialize the modified AST back to a string and return it to the Core.

* **UI Integration:**
* **Visual Feedback:** None required (implicit behavior).
* **Context Menu:** Add "Fill Series" vs "Fill Formatting Only" options (standard behavior handled by the Core's UI, populated by available Providers).