I am building "Calcula," an ambitious open-source spreadsheet engine (Excel alternative) built for high performance and extensibility.

## ARCHITECTURE:

### Microkernel Architecture (VSCode Style)

Calcula follows a strict **Microkernel Architecture**. The application is divided into:

1. **The Kernel (Core)** - A minimal, stable engine that knows *nothing* about specific features.
2. **The Shell (Host)** - The application frame that orchestrates the lifecycle and loads extensions.
3. **The Extensions** - All user-facing features (formatting, charts, sort) are implemented as extensions, even if they are "built-in".

### The Four Layers

1. **The Brain (Backend):** Written in **Rust**. Handles the Cell Dependency Graph, Formula Parsing, and Persistence.
2. **The Face (Core Frontend):** Written in **TypeScript + React**. A pure component that renders the virtualized grid on HTML5 Canvas. It has **zero dependencies** on the Shell or Extensions.
3. **The API (Facade):** A strictly typed "Sandbox" layer. This is the **only** bridge between the Core and Extensions.
4. **The Bridge:** Uses **Tauri** to connect Rust to the WebView.

### Directory Structure

Calcula/
├── app/
│   ├── src/
│   │   ├── core/           # The Engine. PURE. 
│   │   │                   # RULE: Cannot import from 'shell' or 'extensions'.
│   │   │
│   │   ├── shell/          # The Host.
│   │   │                   # Responsibilities: 
│   │   │                   # 1. Mounts the Core Grid.
│   │   │                   # 2. Scans the 'extensions' folder.
│   │   │                   # 3. Registers them into the Core.
│   │   │
│   │   └── api/            # The "Sandpit".
│   │                       # The ONLY interfaces extensions are allowed to touch.
│   │
│   └── extensions/         # <--- MOVED OUTSIDE 'src' (Optional but recommended)
│       ├── _standard/      # Your "Base" extensions.
│       │   ├── formatting/ # Font, Color, Borders
│       │   ├── sorting/    # Sort & Filter logic
│       │   └── charts/     # Charting engine
│       │
│       └── _3rdparty/      # User installed extensions (gitignored)

### What Lives Where

**Core (`app/src/core/`)** - The "Kernel". Universal primitives only:

* Grid rendering pipeline & virtualization
* Selection model & Cursor logic
* Input handling (Keyboard/Mouse primitives)
* Undo/Redo stack
* **Constraint:** Never imports from `shell` or `extensions`.

**Shell (`app/src/shell/`)** - The "Container":

* Window Layout (Sidebar, Status Bar)
* **Extension Host:** Responsible for scanning, loading, and activating extensions.
* **Constraint:** Orchestrates Core and Extensions but contains no business logic.

**API (`app/src/api/`)** - The "Contract":

* `types.ts`: Stable interfaces re-exported from Core.
* `commands.ts`: Registry definitions.
* **Constraint:** The *only* import allowed in an Extension file.

**Extensions (`app/extensions/`)** - The "Features":

* **Built-in:** Formatting, Sort/Filter, Charts, Fin/Stat Functions.
* **User:** Future 3rd party plugins.
* **Constraint:** Must function exactly like 3rd party plugins. No "backdoor" access to Core internal state.

### Extension Points (via `src/api`)

Extensions interact with the Core *exclusively* through the API Facade:

* `commands.register(id, handler)` - Register actions (e.g., "format.bold").
* `ui.ribbon.registerTab(tabDef)` - Inject UI elements.
* `formulas.registerFunction(name, impl)` - Add calculation logic.
* `events.onSelectionChange(cb)` - Listen for context.

## MICROKERNEL RULES (Strict Enforcement):

1. **The "Alien" Rule:** The Core must treat all extensions (even built-in ones like "Sorting") as foreign objects. Hard imports from `core` to `extensions` are **strictly forbidden**.
2. **The Facade Rule:** Extensions may **only** import from `app/src/api`. They must never import deep into `app/src/core/...`.
3. **Dogfooding:** "Base" features (Formatting, Charts) must be built using the public Extension API. If the API cannot support "Sort", the API must be improved, rather than hacking the feature into the Core.
4. **Inversion of Control:** The Core does not call Extensions. The Core emits events/hooks (via the API), and Extensions respond.

## TECH STACK:
* OS: Windows 11
* Backend: Rust (Workspace structure)
* Frontend: React, TypeScript, Vite
* Scripting: Python (embedded for users)

## CODING GUIDELINES:
* **No Placeholders:** Write full implementation code.
* **Windows Native:** Assume Windows paths and environment.
* **Clean Output:** Avoid Unicode characters (check marks, etc.) in terminal outputs; use ASCII alternatives.
* **Modularity:** Keep logic isolated. The UI should never calculate; the Backend should never render.
* **Core/Add-in Separation:** Core never imports from addins. Add-ins only interact with core through extension points.
* **When coding TypeScript the "Folder-as-Module" pattern is preferred in order to keep the files organized into smaller, manageable sizes.

## NAMING CONVENTIONS (Rust <-> TypeScript API Boundary)

### The Golden Rule
- **TypeScript**: Always use `camelCase` for all properties (textColor, backgroundColor, styleIndex)
- **Rust**: Always use `snake_case` for all fields (text_color, background_color, style_index)
- **Serde handles conversion automatically** via `#[serde(rename_all = "camelCase")]`

### Implementation Pattern

**Rust API types** (in `api_types.rs`):
```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]  // <-- This single attribute handles ALL fields
pub struct CellData {
    pub row: u32,
    pub col: u32,
    pub style_index: usize,  // Rust uses snake_case
}
```

**TypeScript types** (in `types.ts`):
```typescript
export interface CellData {
  row: number;
  col: number;
  styleIndex: number;  // TypeScript uses camelCase
}
```

### Rules & Constraints

**Architecture & Import boundaries**

1. **The "Alien" Rule:** The Core (`src/core`) must **never** import from `src/extensions` or `src/shell`.
2. **The Facade Rule:** Extensions (`src/extensions`) must **only** import from `src/api`. Deep imports into `src/core` are strictly forbidden.
3. **Primitive vs. Logic:** If a feature requires new logic (e.g., Sorting), implement generic primitives in Core (e.g., `read/write range`) and the specific business logic in an Extension.
4. **Feature Location:** Default to building features as **Extensions** (`src/extensions/builtin/`) unless they are foundational primitives (like Rendering or Undo/Redo).

**Naming & Data Types (Rust <-> TS Boundary)**
5.  **Strict CamelCase/SnakeCase:**
* **TypeScript:** Always use `camelCase` (e.g., `styleIndex`, `textColor`).
* **Rust:** Always use `snake_case` (e.g., `style_index`, `text_color`).
6.  **Serde Configuration:**
	* Use `#[serde(rename_all = "camelCase")]` on Rust structs.
	* **Never** use manual `#[serde(rename = "...")]` on individual fields.
7.  **Type Centralization:** All Tauri API types must live in `api_types.rs` (Rust) and `types.ts` (TS). These files are the single source of truth.
8.  **Interface Mirroring:** TypeScript interfaces in `types.ts` must exactly mirror Rust structs in `api_types.rs`.

**Coding Standards**
9.  **Completeness:** Provide the full functional block or file. Do not use placeholders like `// ... rest of code`.
10. **Windows Native:** Assume Windows 11 paths and environment.
11. **Clean Output:** Avoid Unicode characters in terminal output (use `[OK]` instead of `✓`).

### Common Mistakes to Avoid
- Using `style_index` in TypeScript (should be `styleIndex`)
- Using `text_color` in TypeScript (should be `textColor`)
- Forgetting `#[serde(rename_all = "camelCase")]` on new Rust structs
- Adding `#[serde(rename = "fieldName")]` to individual fields (use struct-level instead)
- Importing from `addins/` in core code (core must never depend on add-ins)

###  The "Calcula" Decision Matrix
When developing a new feature, ask yourself these three questions to find its home:
Question|If YES...|If NO...
"Is it a Primal? Does the grid need this to simply exist (e.g., coordinates, scrolling, basic pixel rendering)?"|CORE|Move to next question.
"Is it a Bridge? Is this a generic tool that any extension might need (e.g., ""Show a Dialog,"" ""Read a Cell,"" ""Interchange format"")?"|API|Move to next question.
"Is it a Feature? Is this a specific user-facing behavior (e.g., Data Validation, Charts, Pivot, Formatting)?"|EXTENSION|It's an Extension.