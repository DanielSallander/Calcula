<<<< FILE: app/src-tauri/src/lib.rs >>>>
<<<< SEARCH: pub struct AppState { >>>>
<<<< CODE >>>>
pub struct AppState {
    /// Multiple grids, one per sheet
    pub grids: Mutex<Vec<Grid>>,
    /// Sheet names in order
    pub sheet_names: Mutex<Vec<String>>,
    /// Currently active sheet index
    pub active_sheet: Mutex<usize>,
    /// The currently active grid (synced with grids[active_sheet])
    /// Commands use this for all cell operations
    pub grid: Mutex<Grid>,
    pub style_registry: Mutex<StyleRegistry>,
    pub column_widths: Mutex<HashMap<u32, f64>>,
    pub row_heights: Mutex<HashMap<u32, f64>>,
    pub dependents: Mutex<HashMap<(u32, u32), HashSet<(u32, u32)>>>,
    pub dependencies: Mutex<HashMap<(u32, u32), HashSet<(u32, u32)>>>,
    /// Calculation mode: "automatic" or "manual"
    pub calculation_mode: Mutex<String>,
    /// Column-level dependencies: column index -> set of formula cells that depend on entire column
    pub column_dependents: Mutex<HashMap<u32, HashSet<(u32, u32)>>>,
    /// Row-level dependencies: row index -> set of formula cells that depend on entire row
    pub row_dependents: Mutex<HashMap<u32, HashSet<(u32, u32)>>>,
    /// Track which columns each formula cell depends on (for cleanup)
    pub column_dependencies: Mutex<HashMap<(u32, u32), HashSet<u32>>>,
    /// Track which rows each formula cell depends on (for cleanup)
    pub row_dependencies: Mutex<HashMap<(u32, u32), HashSet<u32>>>,
    /// Cross-sheet dependencies: (sheet_name, row, col) -> set of (sheet_index, row, col) that depend on it
    pub cross_sheet_dependents: Mutex<HashMap<(String, u32, u32), HashSet<(usize, u32, u32)>>>,
    /// Track which cross-sheet cells each formula depends on (for cleanup)
    pub cross_sheet_dependencies: Mutex<HashMap<(usize, u32, u32), HashSet<(String, u32, u32)>>>,
}
<<<< END >>>>

<<<< FILE: app/src-tauri/src/lib.rs >>>>
<<<< SEARCH: pub fn create_app_state() -> AppState { >>>>
<<<< CODE >>>>
pub fn create_app_state() -> AppState {
    log_info!("SYS", "Creating AppState");
    let initial_grid = Grid::new();
    AppState {
        grids: Mutex::new(vec![initial_grid.clone()]),
        sheet_names: Mutex::new(vec!["Sheet1".to_string()]),
        active_sheet: Mutex::new(0),
        grid: Mutex::new(initial_grid),
        style_registry: Mutex::new(StyleRegistry::new()),
        column_widths: Mutex::new(HashMap::new()),
        row_heights: Mutex::new(HashMap::new()),
        dependents: Mutex::new(HashMap::new()),
        dependencies: Mutex::new(HashMap::new()),
        calculation_mode: Mutex::new("automatic".to_string()),
        column_dependents: Mutex::new(HashMap::new()),
        row_dependents: Mutex::new(HashMap::new()),
        column_dependencies: Mutex::new(HashMap::new()),
        row_dependencies: Mutex::new(HashMap::new()),
        cross_sheet_dependents: Mutex::new(HashMap::new()),
        cross_sheet_dependencies: Mutex::new(HashMap::new()),
    }
}
<<<< END >>>>

<<<< FILE: app/src-tauri/src/lib.rs >>>>
<<<< SEARCH: pub struct ExtractedRefs { >>>>
<<<< CODE >>>>
pub struct ExtractedRefs {
    /// Individual cell references (row, col) - same sheet only
    pub cells: HashSet<(u32, u32)>,
    /// Column references (column indices)
    pub columns: HashSet<u32>,
    /// Row references (row indices)
    pub rows: HashSet<u32>,
    /// Cross-sheet cell references (sheet_name, row, col)
    pub cross_sheet_cells: HashSet<(String, u32, u32)>,
}

impl ExtractedRefs {
    pub fn new() -> Self {
        ExtractedRefs {
            cells: HashSet::new(),
            columns: HashSet::new(),
            rows: HashSet::new(),
            cross_sheet_cells: HashSet::new(),
        }
    }
}
<<<< END >>>>

<<<< FILE: app/src-tauri/src/lib.rs >>>>
<<<< SEARCH: fn extract_references_recursive(expr: &ParserExpr, grid: &Grid, refs: &mut ExtractedRefs) { >>>>
<<<< CODE >>>>
fn extract_references_recursive(expr: &ParserExpr, grid: &Grid, refs: &mut ExtractedRefs) {
    match expr {
        ParserExpr::Literal(_) => {}
        ParserExpr::CellRef { sheet, col, row } => {
            let col_idx = col_letter_to_index(col);
            // If sheet is specified, this is a cross-sheet reference
            if let Some(sheet_name) = sheet {
                refs.cross_sheet_cells.insert((sheet_name.clone(), *row, col_idx));
            } else {
                refs.cells.insert((*row, col_idx));
            }
        }
        ParserExpr::Range { sheet, start, end } => {
            // Try to match both start and end as CellRefs
            if let (
                ParserExpr::CellRef { col: start_col, row: start_row, .. },
                ParserExpr::CellRef { col: end_col, row: end_row, .. },
            ) = (start.as_ref(), end.as_ref())
            {
                let sc = col_letter_to_index(start_col);
                let ec = col_letter_to_index(end_col);
                let sr = *start_row;
                let er = *end_row;
                // If sheet is specified, these are cross-sheet references
                if let Some(sheet_name) = sheet {
                    for r in sr.min(er)..=sr.max(er) {
                        for c in sc.min(ec)..=sc.max(ec) {
                            refs.cross_sheet_cells.insert((sheet_name.clone(), r, c));
                        }
                    }
                } else {
                    for r in sr.min(er)..=sr.max(er) {
                        for c in sc.min(ec)..=sc.max(ec) {
                            refs.cells.insert((r, c));
                        }
                    }
                }
            } else {
                extract_references_recursive(start, grid, refs);
                extract_references_recursive(end, grid, refs);
            }
        }
        ParserExpr::ColumnRef { start_col, end_col, .. } => {
            let sc = col_letter_to_index(start_col);
            let ec = col_letter_to_index(end_col);
            let min_col = sc.min(ec);
            let max_col = sc.max(ec);
            
            // Register column-level dependencies
            for col in min_col..=max_col {
                refs.columns.insert(col);
            }
            
            // Also add existing cells for immediate evaluation
            for ((r, c), _) in grid.cells.iter() {
                if *c >= min_col && *c <= max_col {
                    refs.cells.insert((*r, *c));
                }
            }
        }
        ParserExpr::RowRef { start_row, end_row, .. } => {
            let min_row = start_row.min(end_row);
            let max_row = start_row.max(end_row);
            
            // Register row-level dependencies
            for row in *min_row..=*max_row {
                refs.rows.insert(row);
            }
            
            // Also add existing cells for immediate evaluation
            for ((r, c), _) in grid.cells.iter() {
                if *r >= *min_row && *r <= *max_row {
                    refs.cells.insert((*r, *c));
                }
            }
        }
        ParserExpr::BinaryOp { left, right, .. } => {
            extract_references_recursive(left, grid, refs);
            extract_references_recursive(right, grid, refs);
        }
        ParserExpr::UnaryOp { operand, .. } => {
            extract_references_recursive(operand, grid, refs);
        }
        ParserExpr::FunctionCall { args, .. } => {
            for arg in args {
                extract_references_recursive(arg, grid, refs);
            }
        }
    }
}
<<<< END >>>>

<<<< FILE: app/src-tauri/src/lib.rs >>>>
<<<< SEARCH: Append to End >>>>
<<<< CODE >>>>

/// Update cross-sheet dependencies for a formula cell
pub fn update_cross_sheet_dependencies(
    formula_cell: (usize, u32, u32), // (sheet_index, row, col) of the formula
    new_refs: HashSet<(String, u32, u32)>, // (sheet_name, row, col) references
    cross_sheet_dependencies: &mut HashMap<(usize, u32, u32), HashSet<(String, u32, u32)>>,
    cross_sheet_dependents: &mut HashMap<(String, u32, u32), HashSet<(usize, u32, u32)>>,
) {
    let old_refs = cross_sheet_dependencies.remove(&formula_cell).unwrap_or_default();
    
    // Remove old cross-sheet dependencies
    for old_ref in &old_refs {
        if let Some(deps) = cross_sheet_dependents.get_mut(old_ref) {
            deps.remove(&formula_cell);
            if deps.is_empty() {
                cross_sheet_dependents.remove(old_ref);
            }
        }
    }
    
    // Add new cross-sheet dependencies
    for new_ref in &new_refs {
        cross_sheet_dependents
            .entry(new_ref.clone())
            .or_insert_with(HashSet::new)
            .insert(formula_cell);
    }
    
    if !new_refs.is_empty() {
        log_debug!("XDEP", "formula={:?} cross_sheet_refs={}", formula_cell, new_refs.len());
        cross_sheet_dependencies.insert(formula_cell, new_refs);
    }
}
<<<< END >>>>

<<<< FILE: app/src-tauri/src/commands.rs >>>>
<<<< SEARCH: pub fn update_cell( >>>>
<<<< CODE >>>>
pub fn update_cell(
    state: State<AppState>,
    row: u32,
    col: u32,
    value: String,
) -> Result<Vec<CellData>, String> {
    let sheet_names = state.sheet_names.lock().unwrap();
    let mut grid = state.grid.lock().unwrap();
    let mut grids = state.grids.lock().unwrap();
    let active_sheet = *state.active_sheet.lock().unwrap();
    let styles = state.style_registry.lock().unwrap();
    let mut dependents_map = state.dependents.lock().unwrap();
    let mut dependencies_map = state.dependencies.lock().unwrap();
    let mut column_dependents_map = state.column_dependents.lock().unwrap();
    let mut column_dependencies_map = state.column_dependencies.lock().unwrap();
    let mut row_dependents_map = state.row_dependents.lock().unwrap();
    let mut row_dependencies_map = state.row_dependencies.lock().unwrap();
    let mut cross_sheet_dependents_map = state.cross_sheet_dependents.lock().unwrap();
    let mut cross_sheet_dependencies_map = state.cross_sheet_dependencies.lock().unwrap();
    let calc_mode = state.calculation_mode.lock().unwrap();

    let current_sheet_name = sheet_names.get(active_sheet).cloned().unwrap_or_default();
    let mut updated_cells = Vec::new();

    // Handle empty value - clear the cell
    if value.trim().is_empty() {
        grid.clear_cell(row, col);
        // Also update the grids vector
        if active_sheet < grids.len() {
            grids[active_sheet].clear_cell(row, col);
        }
        // Clear cross-sheet dependencies
        update_cross_sheet_dependencies(
            (active_sheet, row, col),
            HashSet::new(),
            &mut cross_sheet_dependencies_map,
            &mut cross_sheet_dependents_map,
        );
        update_dependencies(
            (row, col),
            HashSet::new(),
            &mut dependencies_map,
            &mut dependents_map,
        );
        update_column_dependencies(
            (row, col),
            HashSet::new(),
            &mut column_dependencies_map,
            &mut column_dependents_map,
        );
        update_row_dependencies(
            (row, col),
            HashSet::new(),
            &mut row_dependencies_map,
            &mut row_dependents_map,
        );
        updated_cells.push(CellData {
            row,
            col,
            display: String::new(),
            formula: None,
            style_index: 0,
        });
        return Ok(updated_cells);
    }

    // Parse the input
    let mut cell = parse_cell_input(&value);

    // Preserve existing style
    if let Some(existing) = grid.get_cell(row, col) {
        cell.style_index = existing.style_index;
    }

    // If it's a formula, evaluate it using multi-sheet context
    if let Some(ref formula) = cell.formula {
        // Extract references for dependency tracking
        if let Ok(parsed) = parser::parse(formula) {
            let refs = extract_all_references(&parsed, &grid);
            update_dependencies((row, col), refs.cells, &mut dependencies_map, &mut dependents_map);
            update_column_dependencies((row, col), refs.columns, &mut column_dependencies_map, &mut column_dependents_map);
            update_row_dependencies((row, col), refs.rows, &mut row_dependencies_map, &mut row_dependents_map);
            
            // Track cross-sheet dependencies
            update_cross_sheet_dependencies(
                (active_sheet, row, col),
                refs.cross_sheet_cells,
                &mut cross_sheet_dependencies_map,
                &mut cross_sheet_dependents_map,
            );
        }

        // Evaluate using multi-sheet context for cross-sheet reference support
        let result = evaluate_formula_multi_sheet(
            &grids,
            &sheet_names,
            active_sheet,
            formula,
        );
        cell.value = result;
    } else {
        // Clear dependencies for non-formula cells
        update_dependencies(
            (row, col),
            HashSet::new(),
            &mut dependencies_map,
            &mut dependents_map,
        );
        update_cross_sheet_dependencies(
            (active_sheet, row, col),
            HashSet::new(),
            &mut cross_sheet_dependencies_map,
            &mut cross_sheet_dependents_map,
        );
        update_column_dependencies(
            (row, col),
            HashSet::new(),
            &mut column_dependencies_map,
            &mut column_dependents_map,
        );
        update_row_dependencies(
            (row, col),
            HashSet::new(),
            &mut row_dependencies_map,
            &mut row_dependents_map,
        );
    }

    // Store the cell
    grid.set_cell(row, col, cell.clone());
    // Also update the grids vector to keep them in sync
    if active_sheet < grids.len() {
        grids[active_sheet].set_cell(row, col, cell.clone());
    }

    // Get the display value
    let style = styles.get(cell.style_index);
    let display = format_cell_value(&cell.value, style);

    updated_cells.push(CellData {
        row,
        col,
        display,
        formula: cell.formula.clone(),
        style_index: cell.style_index,
    });

    // Recalculate dependents if automatic mode
    if *calc_mode == "automatic" {
        // Get direct cell dependents
        let mut recalc_order = get_recalculation_order((row, col), &dependents_map);
        
        // Also get column/row dependents (formulas with column or row references)
        let col_row_deps = get_column_row_dependents((row, col), &column_dependents_map, &row_dependents_map);
        for dep in col_row_deps {
            if !recalc_order.contains(&dep) {
                recalc_order.push(dep);
            }
        }

        for (dep_row, dep_col) in recalc_order {
            if let Some(dep_cell) = grid.get_cell(dep_row, dep_col) {
                if let Some(ref formula) = dep_cell.formula {
                    // Evaluate dependent using multi-sheet context
                    let result = evaluate_formula_multi_sheet(
                        &grids,
                        &sheet_names,
                        active_sheet,
                        formula,
                    );

                    let mut updated_dep = dep_cell.clone();
                    updated_dep.value = result;
                    grid.set_cell(dep_row, dep_col, updated_dep.clone());
                    
                    // Also update the grids vector
                    if active_sheet < grids.len() {
                        grids[active_sheet].set_cell(dep_row, dep_col, updated_dep.clone());
                    }

                    let dep_style = styles.get(updated_dep.style_index);
                    let dep_display = format_cell_value(&updated_dep.value, dep_style);

                    updated_cells.push(CellData {
                        row: dep_row,
                        col: dep_col,
                        display: dep_display,
                        formula: updated_dep.formula.clone(),
                        style_index: updated_dep.style_index,
                    });
                }
            }
        }

        // Recalculate cross-sheet dependents (formulas on OTHER sheets that reference this cell)
        let cross_sheet_key = (current_sheet_name.clone(), row, col);
        if let Some(cross_deps) = cross_sheet_dependents_map.get(&cross_sheet_key) {
            for (dep_sheet_idx, dep_row, dep_col) in cross_deps.iter() {
                // Skip if it's on the current sheet (already handled above)
                if *dep_sheet_idx == active_sheet {
                    continue;
                }
                
                // Get the dependent cell from its sheet
                if *dep_sheet_idx < grids.len() {
                    if let Some(dep_cell) = grids[*dep_sheet_idx].get_cell(*dep_row, *dep_col) {
                        if let Some(ref formula) = dep_cell.formula {
                            // Evaluate the formula in context of its own sheet
                            let result = evaluate_formula_multi_sheet(
                                &grids,
                                &sheet_names,
                                *dep_sheet_idx,
                                formula,
                            );

                            let mut updated_dep = dep_cell.clone();
                            updated_dep.value = result;
                            grids[*dep_sheet_idx].set_cell(*dep_row, *dep_col, updated_dep.clone());

                            // Note: Cross-sheet updates not added to updated_cells
                            // Frontend refreshes when switching sheets
                        }
                    }
                }
            }
        }
    }

    Ok(updated_cells)
}
<<<< END >>>>

<<<< FILE: app/src-tauri/src/commands.rs >>>>
<<<< SEARCH: use crate::{ >>>>
<<<< CODE >>>>
use crate::{
    create_app_state, evaluate_formula, evaluate_formula_multi_sheet, extract_references,
    extract_all_references, format_cell_value, get_recalculation_order, get_column_row_dependents,
    parse_cell_input, update_dependencies, update_column_dependencies, update_row_dependencies,
    update_cross_sheet_dependencies,
    AppState,
};
<<<< END >>>>

<<<< FILE: app/src/shell/SheetTabs/SheetTabs.tsx >>>>
<<<< SEARCH: const handleSheetClick = useCallback( >>>>
<<<< CODE >>>>
const handleSheetClick = useCallback(
    async (index: number) => {
      if (index === activeIndex) return;

      console.log("[SheetTabs] Sheet click, index:", index, "isInFormulaMode:", isInFormulaMode);

      // Emit before event
      await sheetExtensions.emit({
        type: "sheet:beforeSwitch",
        sheetIndex: index,
        sheetName: sheets[index]?.name || "",
        previousIndex: activeIndex,
      });

      try {
        // When in formula mode, we need special handling
        if (isInFormulaMode) {
          console.log("[SheetTabs] Formula mode - switching without reload");
          
          // Just update the backend's active sheet for cell selection
          // but DON'T reload the page or exit edit mode
          const result: SheetsResult = await setActiveSheetApi(index);
          setSheets(result.sheets);
          setActiveIndex(result.activeIndex);
          
          const newActiveSheet = result.sheets[result.activeIndex];
          
          // Update the grid state with new sheet context
          // This allows the grid to show the new sheet's cells
          // while keeping the formula editing state intact
          if (newActiveSheet) {
            dispatch(setActiveSheet(result.activeIndex, newActiveSheet.name));
          }

          // Emit after event
          await sheetExtensions.emit({
            type: "sheet:afterSwitch",
            sheetIndex: result.activeIndex,
            sheetName: newActiveSheet?.name || "",
            previousIndex: activeIndex,
          });

          onSheetChange?.(result.activeIndex, newActiveSheet?.name || "");
          
          // Emit a custom event to trigger grid refresh and editor refocus
          // GridCanvas listens for this to re-fetch cells
          // InlineEditor listens for this to refocus and clear the prevent flag
          console.log("[SheetTabs] Dispatching sheet:formulaModeSwitch event");
          window.dispatchEvent(new CustomEvent("sheet:formulaModeSwitch", {
            detail: {
              newSheetIndex: result.activeIndex,
              newSheetName: newActiveSheet?.name || "",
            }
          }));
          
          // Focus the formula bar since InlineEditor won't render on target sheet
          // This matches Excel behavior where formula bar stays active during cross-sheet selection
          setTimeout(() => {
            const formulaBar = document.querySelector('[data-formula-bar="true"]') as HTMLInputElement;
            if (formulaBar) {
              formulaBar.focus();
              const len = formulaBar.value.length;
              formulaBar.setSelectionRange(len, len);
            }
          }, 50);
          
          // DO NOT reload - stay in edit mode for formula reference selection
          return;
        }

        // Normal mode: switch sheets with full reload
        const result: SheetsResult = await setActiveSheetApi(index);
        setSheets(result.sheets);
        setActiveIndex(result.activeIndex);
        
        const newActiveSheet = result.sheets[result.activeIndex];
        
        if (newActiveSheet) {
          dispatch(setActiveSheet(result.activeIndex, newActiveSheet.name));
        }

        await sheetExtensions.emit({
          type: "sheet:afterSwitch",
          sheetIndex: result.activeIndex,
          sheetName: newActiveSheet?.name || "",
          previousIndex: activeIndex,
        });

        onSheetChange?.(result.activeIndex, newActiveSheet?.name || "");
        
        // Reload to refresh grid data (only in non-formula mode)
        window.location.reload();
      } catch (err) {
        console.error("[SheetTabs] setActiveSheet error:", err);
        // Clear the prevent flag on error
        setPreventBlurCommit(false);
        alert("Failed to switch sheet: " + String(err));
      }
    },
    [activeIndex, sheets, onSheetChange, isInFormulaMode, dispatch]
  );
<<<< END >>>>